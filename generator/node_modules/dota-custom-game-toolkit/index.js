var path = require("path"),
	vdf = require("vdf-extra"),
	fs = require("fs-extra"),
	_ = require("lodash"),
	yaml = require("js-yaml");
var Promise = require("bluebird");
/*var basedir = path.join(__dirname, "..")
var contentDir = path.join(basedir, "content")
var gameDir = path.join(basedir, "game")
var npcDir = path.join(gameDir, "scripts/npc")
var resourceDir = path.join(gameDir, "resource")
var tooltipgen = vorpal.command("tooltipgen <filename> [output]", 'Generates Tooltip list, based on info from specified KV file')
var langupd = vorpal.command('langupd', 'Lists differences between primary and other language files')
var settings = {
	"tooltipgen": {
		"AbilitySpecialMap": {
			"bonus_agility": "+$agi",
			"bonus_agi": "+$agi",
			"think_interval": "{REMOVE}",
			"crit_chance": {
				"english": "CRITICAL STRIKE CHANCE:",
				"russian": "ШАНС КРИТА:"
			}
		}
	},
	"langupd": {
		"primary": "english",
		"IndentLength": 92,
		"IndentString": "\t",
	}
}

function GenerateTooltips(text, reject) {
	var parsed = vdf.parse(text, npcDir);
	var tooltips = {}
	var tooltipgen_ASMap = settings.tooltipgen.AbilitySpecialMap
	var IndentLength = settings.langupd.IndentLength
	var primaryLocalizationFile = ReadLocalization(settings.langupd.primary, "resource");
	var Localizations = {};
	GetAvaliableLocalizations("resource").then(allLocales => {
		for (var dataroot in parsed) {
			var data = parsed[dataroot]
			for (var className in data) {
				console.log(className)
				var LocalizationBlock = {};

				console.log(allLocales)
				for (var i in allLocales) {
					LocalizationBlock[allLocales[i]] = {};
				}
				console.log(LocalizationBlock)
				var AddLocalToBlock = function(type, key, param) {
					for (var locale in LocalizationBlock) {
						if (primaryLocalizationFile[key] == null) {
							var value;
							switch (type) {
								case "ability":
									value = param.replace(new RegExp("_", "g"), " ").replace(/\w\Sg, function(txt) {
										return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
									})
									break
								case "AbilitySpecial":
									value = tooltipgen_ASMap[param];
									if (typeof value == "object") {
										value = value[locale] || value.english || value[0]
									}
									if (typeof value == "string") {
										if (value == "{REMOVE}") {
											value = null;
										}
									} else if (value == null)
										value = ((param.endsWith("_pct") ? "%" : "") + param.replace(new RegExp("_", "g"), " ").toUpperCase() + ":");
									break
								default:
									value = param;
							}
							LocalizationBlock[locale][key] = value;
						}
					}
				}
				var classData = data[className]
				AddLocalToBlock("ability", "DOTA_Tooltip_ability_" + className, className)
				AddLocalToBlock(null, "DOTA_Tooltip_ability_" + className + "_Description", "");
				if (true) { // ability/item
					if (classData.AbilitySpecial) {
						for (var specialIndex in classData.AbilitySpecial) {
							var specialData = classData.AbilitySpecial[specialIndex]
							for (var k in specialData) {
								var v = specialData[v]
								if (k != "var_type" && k != "CalculateSpellDamageTooltip") {
									AddLocalToBlock("AbilitySpecial", "DOTA_Tooltip_ability_" + className + "_" + k, k);
								}
							}
						}
					}
				}
				console.log(LocalizationBlock)
				for (var locale in LocalizationBlock) {
					Localizations[locale] = Localizations[locale] || "";
					for (var key in LocalizationBlock[locale]) {
						var value = LocalizationBlock[locale][key]
						IndentLength
						var keyStr = '"' + key + '"'
						var kvindent = ""
						while (keyStr.length + kvindent.length * IndentString == "\t" ? 4 : 1 < kvIndentLength) {
							kvindent += IndentString;
						}
						Localizations[locale] += keyStr + kvindent + '"' + String(obj[key]) + '"\n'
					}
					Localizations[locale] += "\n"
				}
			}
		}
		for (var locale in Localizations) {
			fs.writeFile("outputs/tooltips_" + locale + ".txt", Localizations[locale], function(err) {
				if (err)
					reject("tooltips.txt write error");
			});
		}
	});
}
tooltipgen.action(function(args, callback) {
	new Promise((resolve, reject) => {
		var filename = args.filename
		var fullpath = path.join(npcDir, filename)
		var ext = path.extname(fullpath);
		if (ext.length <= 1)
			fullpath = fullpath + ".txt"
		fs.access(fullpath, fs.F_OK, error => {
			if (error)
				reject("specified file not found")
			else
				fs.readFile(fullpath, 'utf-8', (err, data) => {
					if (err) reject(err);
					GenerateTooltips(data, reject)
				});
		});
	}).catch(err => {
		this.log("ERROR: " + err)
	});
	callback();
});

langupd.action(function(args, callback) {
	new Promise((resolve, reject) => {
		var panoramaLangDir = path.join(gameDir, "panorama/localization")
		fs.readdir(resourceDir, function(err, files) {
			if (err)
				reject("Could not list the directory")
			else {
				for (var index = 0; index < files.length; index++) {
					var file = files[index];
					var filePathFull = path.join(resourceDir, file);
					if (file.startsWith("addon_")) {
						//var language = ;
					}
				}
			}
		});
	}).catch(err => {
		this.log("ERROR: " + err)
	});
	callback();
});

function ReadLocalization(lang, type) {
	var pathes;
	var kv = {};
	switch (type) {
		case "resource":
			pathes = [path.join(resourceDir, "addon_" + lang + ".txt")];
			break;
		case "panorama":
			pathes = [path.join(gameDir, "panorama/localization/addon_" + lang + ".txt")];
			break;
		default:
			pathes = [
				path.join(resourceDir, "addon_" + lang + ".txt"),
				path.join(gameDir, "panorama/localization/addon_" + lang + ".txt")
			]
	}
	for (var i in pathes) {
		var file = pathes[i]
		fs.access(file, fs.F_OK, error => {
			//if (error)
			//	reject("specified file not found")
			//else
			var parsed = vdf.parse(fs.readFileSync(file, 'ucs2'), path.dirname(file));
			if (parsed.Tokens != null)
				deepmerge(kv, parsed.Tokens)
		});
	}
	return kv;
}*/

function readdirp(dirPath) {
	var paths = [];
	return fs.readdir(dirPath)
		.then(subPaths => {
			return Promise.map(subPaths, subPath => {
				subPath = path.join(dirPath, subPath);
				return fs.stat(subPath)
					.then(subPathStat => {
						if (subPathStat.isDirectory()) {
							return readdirp(subPath)
								.then(subSubPaths => {
									paths = _.concat(paths, subSubPaths);
								});
						} else {
							return paths.push(subPath);
						}
					});
			});
		})
		.then(() => {
			return paths;
		});
}

function ParseLocalesFromDirectory(localizationDir) {
	return readdirp(localizationDir)
		.then(paths => {
			return Promise.map(paths, _localeElement => {
				let localeElement = path.relative(localizationDir, _localeElement);
				let locale = localeElement.split("\\")[0];
				if (localeElement.endsWith(".yml")) {
					return fs.readFile(_localeElement, "utf-8")
						.then(fileText => {
							let parsedFileContent;
							try {
								parsedFileContent = yaml.safeLoad(fileText);
							} catch (err) {
								if (err.name === "YAMLException") {
									let mark = err.mark;
									console.error({
										file: _localeElement.replace(/\\/g, "/"),
										column: mark.column,
										line: mark.line,
										reason: err.reason,
										message: err.message,
									});
								} else {
									throw err;
								}
							}
							return _.assign(parsedFileContent, {Language: locale});
						});
				} else {
					console.warn("Only yaml localization files are allowed, file ", _localeElement, " is unhandled");
				}
			});
		})
		.then(localizations => {
			return ParseLocalesFromObject(localizations);
		});
}

//Input: Array of localizations with fixed Keyword Language.
//Output: Object - locale - Tokens
//Keywords: Language, Variables
function ParseLocalesFromObject(kvs) {
	let groupedKVs = _.groupBy(kvs, "Language");
	let tokensByLanguages = {};
	_.each(groupedKVs, (tokenArrays, language) => {
		let variables = {};
		let tokens = {};

		//First - parsing Variables
		_.each(tokenArrays, kv => {
			if (kv.Variables) _.assign(variables, kv.Variables);
			delete kv.Language;
			delete kv.Variables;
		});

		//Second - parsing tokens
		_.each(tokenArrays, kv => {
			_.each(kv, (value, keys) => {
				if (_.isArray(value)) {
					let t = keys;
					keys = value;
					value = t;
				}
				_.each(_.isArray(keys) ? keys : [keys], key => {
					if (tokens[key]) {
						throw new Error("Key " + key + " presents in multiple files");
					} else {
						tokens[key] = value.replace(/\{lc:.+}/g, matched => {
							var variable = matched.slice(4, -1);
							if (variables[variable]) {
								return variables[variable];
							} else {
								console.warn("Unhandled lc variable: ", variable, " (", language, "localization )");
								return "";
							}
						});
					}
				});
			});
		});

		//Third - applying custom rules
		_.each(tokens, (value, key) => {
			if (key.endsWith("_Description")) {
				//Has scepter description?
				if (tokens[key.slice(0, -"Description".length) + "aghanim_description"]) {
					tokens[key] += "\n" + variables.ability_scepter_upgradable;
				}
			}
		});

		tokensByLanguages[language] = tokens;
	});
	return tokensByLanguages;
}

function KVToYaml(file) {
	return fs.readFile(file + ".txt", "utf8")
		.then(content => {
			return vdf.parse(content, {
				getBaseFile: basePath => {return fs.readFile(basePath);}
			});
		})
		.then(obj => {
			return fs.outputFile(file + ".yml", yaml.safeDump(obj, {lineWidth: Number.MAX_VALUE}), "utf8");
		});
}

function YamlToKV(file) {
	return fs.readFile(file + ".yml", "utf8")
		.then(content => {
			return fs.outputFile(file + ".txt", vdf.stringify(yaml.safeLoad(content), -1), "utf8");
		});
}

module.exports = {
	ParseLocalesFromDirectory: ParseLocalesFromDirectory,
	ParseLocalesFromObject: ParseLocalesFromObject,
};
