/*
VDF (de)serialization
Copyright (c) 2010-2013, Anthony Garcia <anthony@lagg.me>
Distributed under the ISC License (see LICENSE)

Ported to node.js by Rob Jackson - rjackson.me.
By ark120202: rewritten _dump function, added #base support, array handling and merge roots arguments.
*/

var _ = require('lodash');

var STRING = '"',
	NODE_OPEN = '{',
	NODE_CLOSE = '}',
	BR_OPEN = '[',
	BR_CLOSE = ']',
	COMMENT = '/',
	CR = '\r',
	LF = '\n',
	SPACE = ' ',
	TAB = '\t',
	WHITESPACE = [SPACE, '\t', '\r', '\n'],
	BASE = '#base ';

function _symtostr(line, i, token) {
	token = token || STRING;

	var opening = i + 1,
		closing = opening;

	var ci = line.indexOf(token, opening);
	while (ci !== -1) {
		if (line.substring(ci - 1, ci) !== '\\') {
			closing = ci;
			break;
		}
		ci = line.indexOf(token, ci + 1);
	}

	var finalstr = line.substring(opening, closing);
	return [finalstr, i + finalstr.length + 1];
}

function _unquotedtostr(line, i) {
	var ci = i;
	while (ci < line.length) {
		if (WHITESPACE.indexOf(line.substring(ci, ci + 1)) > -1) {
			break;
		}
		ci += 1;
	}
	return [line.substring(i, ci), ci];
}

function throwBsaeParseError() {
	throw new Error('#base is allowed only in kv root');
}

function _parse(stream, ptr, getBaseFile, mergeRoots, handleMultipleKeys) {
	ptr = ptr || 0;

	var laststr,
		lasttok,
		lastbrk,
		i = ptr,
		next_is_value = false,
		deserialized = {},
		bases = [];

	while (i < stream.length) {
		let c = stream.substring(i, i + 1);

		switch(c) {
			case NODE_OPEN: {
				next_is_value = false;  // Make sure the next string is interpreted as a key.

				let parsed = _parse(stream, i + 1, throwBsaeParseError, false, handleMultipleKeys);
				deserialized[laststr] = parsed[0];
				i = parsed[1];
				break;
			}
			case NODE_CLOSE: {
				return [deserialized, i];
			}
			case BR_OPEN: {
				let _string = _symtostr(stream, i, BR_CLOSE);
				lastbrk = _string[0];
				i = _string[1];
				break;
			}
			case COMMENT: {
				if ((i + 1) < stream.length && stream.substring(i + 1, i + 2) === '/') {
					i = stream.indexOf('\n', i);
				}
				break;
			}
			case CR:
			case LF:
				var ni = i + 1;
				if (ni < stream.length && stream.substring(ni, ni + 1) === LF) {
					i = ni;
				}
				if (lasttok !== LF) {
					c = LF;
				}
				break;
			case BASE[0]: {
				if (i + BASE.length < stream.length) {
					if (stream.substring(i, i + BASE.length) === BASE) {
						let thisPath = stream.substring(i + BASE.length, stream.indexOf('\n', i)).replace(/\r?\n|\r/g, '');
						if (thisPath.startsWith('"') && thisPath.endsWith('"')) {
							thisPath = thisPath.slice(1, -1);
						}
						if (getBaseFile) {
							bases.push(
								Promise.resolve(getBaseFile(thisPath))
									.then(x => {
										return _parse(x, null, getBaseFile, true, handleMultipleKeys);
									})
							);
						} else {
							throw new Error('getBaseFile is undefined, but kv contains #base');
						}
						i = stream.indexOf('\n', i);
					}
				}
				break;
			}
			default: {
				if (c !== SPACE && c !== TAB) {
					let _string = (c === STRING ? _symtostr : _unquotedtostr)(stream, i);
					let string = _string[0].replace(/\\\\/g, '\\').replace(/\\"/g, '"').replace(/\\n/g, '\n').replace(/\\t/g, '\t');
					i = _string[1];

					if (lasttok === STRING && next_is_value) {
						if (deserialized[laststr] && lastbrk != null) {
							lastbrk = null;  // Ignore this sentry if it's the second bracketed expression
						} else if (handleMultipleKeys && laststr in deserialized) {
							if (!Array.isArray(deserialized[laststr])) deserialized[laststr] = [deserialized[laststr]];
							deserialized[laststr].push(string);
						} else {
							deserialized[laststr] = string;
						}
					}
					c = STRING;  // Force c == string so lasttok will be set properly.
					laststr = string;
					next_is_value = !next_is_value;
				} else {
					c = lasttok;
				}
			}
		}

		lasttok = c;
		i += 1;
	}

	if (getBaseFile && getBaseFile !== throwBsaeParseError) {
		return Promise.all(bases).then(basesParsed => {
			let fk = _.keys(deserialized)[0];
			_.each(basesParsed, baseParsed => {
				deserialized[fk] = _.merge(baseParsed[0], deserialized[fk]); //Main KV takes priority over bases
			});
			return [mergeRoots ? deserialized[fk] : deserialized, i];
		});
	} else {
		return [mergeRoots ? deserialized[_.keys(deserialized)[0]] : deserialized, i];
	}
}

function _dump(obj, indentLength, pretty, level) {
	if (typeof obj !== 'object') {
		throw new TypeError('VDF.stringify: a key has value of type other than string or object');
	}

	var buf = '';
	var indent = '\t';
	var newline = pretty ? '\n' : ' ';

	var preLineIndent = '';
	if (pretty) {
		for (var i = 0; i < level; i++) {
			preLineIndent += indent;
		}
	}

	_.each(obj, (value, key) => {
		var firstLinePart = preLineIndent + '"' + key + '"';
		if (typeof value === 'object') {
			var dumpedValue = _dump(value instanceof Array ? value.reduce((acc, item) => {
				acc[item] = 1;
				return acc;
			}, {}) : value, indentLength, pretty, level + 1);
			buf += [firstLinePart, newline, preLineIndent, '{', newline, dumpedValue, preLineIndent, '}', newline].join('');
		} else {
			var keyValueIndent = '';
			if (pretty) {
				if (indentLength === -1) {
					keyValueIndent += '\t\t';
				} else {
					while ((firstLinePart + keyValueIndent).replace(/\t/g, '    ').length < indentLength) {
						keyValueIndent += indent;
					}
				}
			} else {
				keyValueIndent = ' ';
			}
			if (keyValueIndent.length === 0) keyValueIndent = '';
			value = String(value);
			value = value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\t/g, '\\t');
			buf += [firstLinePart, keyValueIndent, '"', value, '"', newline].join('');
		}
	});

	return buf;
}

exports.parse = function parse(string, options) {
	options = options || {};
	let _parsed = _parse(string, null, options.getBaseFile, options.mergeRoots !== false, options.handleMultipleKeys);
	if (_parsed instanceof Promise) {
		return _parsed.then(_parsedList => {
			return _parsedList[0];
		});
	} else {
		return _parsed[0];
	}
};

exports.stringify = function stringify(obj, indentLength) {
	if (indentLength == null) indentLength = -1;
	if (indentLength !== -1 && indentLength % 4 !== 0) throw new Error('Indent Length must be dividable by 4');
	return _dump(obj, indentLength, indentLength !== 0, 0);
};
